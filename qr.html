<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dynamic QR Router</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 1.5rem; }
    h1, h2 { margin-top: 0; }
    label { display: block; margin-top: 0.75rem; font-weight: 600; }
    input, select, textarea { width: 100%; max-width: 600px; padding: 0.35rem 0.5rem; margin-top: 0.25rem; font-size: 0.95rem; }
    button { margin-top: 0.8rem; padding: 0.4rem 0.8rem; font-size: 0.95rem; cursor: pointer; }
    .row { display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start; }
    .col { flex: 1 1 260px; min-width: 260px; }
    .small { font-size: 0.8rem; color: #555; }
    pre { background:#f4f4f4; padding:0.5rem; overflow:auto; max-width: 600px; }
    #message { margin-top: 0.5rem; color: #333; font-size: 0.9rem; }
    #qrContainer svg { border:1px solid #ccc; margin-top:0.5rem; }
    table { border-collapse: collapse; margin-top:0.75rem; }
    th, td { border:1px solid #ccc; padding:0.25rem 0.5rem; font-size:0.8rem; }
    th { background:#f8f8f8; }
    .pill { display:inline-block; padding:0.1rem 0.4rem; border-radius:999px; font-size:0.7rem; background:#eee; }
    .hidden { display:none; }
  </style>
</head>
<body>
<h1>Dynamic QR Router</h1>
<div id="message"></div>

<div id="adminUI" class="hidden">
  <div class="row">
    <div class="col">
      <h2>Create / update QR code</h2>
      <label>
        QR key (e.g. "promo1")
        <input id="codeKey" placeholder="short identifier used in ?code=..." />
      </label>

      <label>
        Action type
        <select id="actionType">
          <option value="redirect">Redirect to URL</option>
          <option value="redirectWithParams">Redirect with URL parameters</option>
          <option value="download">Trigger download (data URL or http(s) URL)</option>
          <option value="display">Display data</option>
        </select>
      </label>

      <div id="field_targetUrl">
        <label>
          Target URL
          <input id="targetUrl" placeholder="https://example.com/page" />
        </label>
      </div>

      <div id="field_params" class="hidden">
        <label>
          Extra URL parameters (JSON object)
          <textarea id="extraParams" rows="3" placeholder='{"utm_source":"qr","campaign":"spring"}'></textarea>
        </label>
      </div>

      <div id="field_download" class="hidden">
        <label>
          Download URL or data URI
          <input id="downloadUrl" placeholder="https://example.com/file.pdf or data:...;base64,..." />
        </label>
        <label>
          Suggested filename
          <input id="downloadName" placeholder="file.pdf" />
        </label>
      </div>

      <div id="field_display" class="hidden">
        <label>
          Display text / data (HTML allowed)
          <textarea id="displayData" rows="4" placeholder="This is some content shown for this QR code."></textarea>
        </label>
      </div>

      <button id="saveCode">Save / update code</button>
      <div class="small">
        Codes are stored in your browser only (localStorage). No server is called.
      </div>

      <h3 style="margin-top:1.5rem;">Generated QR (for this key)</h3>
      <div class="small">
        Scalable SVG, encodes this page with <code>?code=&lt;your-key&gt;</code>.
      </div>
      <pre id="qrUrl"></pre>
      <div id="qrContainer"></div>
      <button id="downloadSvgBtn" class="hidden">Download SVG</button>
    </div>

    <div class="col">
      <h2>Existing codes</h2>
      <div class="small">Click a key to load it into the editor.</div>
      <div id="codeList"></div>
    </div>
  </div>
</div>

<div id="displayArea" class="hidden">
  <h2>QR content</h2>
  <div id="displayContent"></div>
</div>

<script>
/*
  Single function orchestrating everything:
  - parse query and storage
  - execute actions (redirect, download, display)
  - render admin UI when no ?code=
  - generate SVG QR (no external deps, no network)
*/
(function dynamicQRRouter() {
  "use strict";

  // --- tiny helpers (still inside the IIFE) -----------------
  function $(id) { return document.getElementById(id); }

  function loadCodes() {
    try {
      const raw = localStorage.getItem("dynamicQrCodes") || "{}";
      return JSON.parse(raw);
    } catch (e) {
      return {};
    }
  }

  function saveCodes(codes) {
    localStorage.setItem("dynamicQrCodes", JSON.stringify(codes));
  }

  function updateCodeList(codes) {
    const container = $("codeList");
    container.innerHTML = "";
    const keys = Object.keys(codes).sort();
    if (!keys.length) {
      container.textContent = "No codes yet.";
      return;
    }
    const table = document.createElement("table");
    const thead = document.createElement("thead");
    thead.innerHTML = "<tr><th>Key</th><th>Action</th></tr>";
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    keys.forEach(k => {
      const tr = document.createElement("tr");
      const tdKey = document.createElement("td");
      const link = document.createElement("button");
      link.textContent = k;
      link.style.border = "none";
      link.style.background = "none";
      link.style.padding = "0";
      link.style.cursor = "pointer";
      link.style.color = "#0366d6";
      link.onclick = function () {
        loadToForm(k, codes[k]);
      };
      tdKey.appendChild(link);
      const tdAction = document.createElement("td");
      tdAction.innerHTML = "<span class='pill'>" + codes[k].type + "</span>";
      tr.appendChild(tdKey);
      tr.appendChild(tdAction);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  function setMessage(msg) {
    $("message").textContent = msg || "";
  }

  function show(elOrId, show) {
    const el = typeof elOrId === "string" ? $(elOrId) : elOrId;
    if (!el) return;
    el.classList[show ? "remove" : "add"]("hidden");
  }

  // --- QR generation (minimal, numeric+alnum, SVG) -----------------
  // For simplicity this uses a very small, fixed-size QR implementation
  // (version 2, ECC level L-like behaviour; not production-grade but fine for short URLs).
  // Encodes input in byte mode and draws modules as <rect>s.


function makeQrSvg(text, scale = 4, margin = 4, ecLevel = 'M') {
  // Minimal, self-contained QR Code generator (adapted compact implementation).
  // Produces an SVG string. Supports automatic version selection up to version 40.
  // ecLevel: 'L','M','Q','H'
  // scale: pixels per module; margin: modules of quiet zone

  // --- QR Math ---
  const QRMath = (function () {
    const EXP_TABLE = new Array(256);
    const LOG_TABLE = new Array(256);
    for (let i = 0; i < 8; i++) EXP_TABLE[i] = 1 << i;
    for (let i = 8; i < 256; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];
    }
    for (let i = 0; i < 255; i++) LOG_TABLE[EXP_TABLE[i]] = i;
    return {
      glog: function (n) {
        if (n < 1) throw new Error("glog(" + n + ")");
        return LOG_TABLE[n];
      },
      gexp: function (n) {
        while (n < 0) n += 255;
        while (n >= 256) n -= 255;
        return EXP_TABLE[n];
      }
    };
  })();

  // --- Reed-Solomon polynomial generator ---
  function createGeneratorPolynomial(degree) {
    let poly = [1];
    for (let i = 0; i < degree; i++) {
      poly = multiplyPoly(poly, [1, QRMath.gexp(i)]);
    }
    return poly;
  }
  function multiplyPoly(a, b) {
    const result = new Array(a.length + b.length - 1).fill(0);
    for (let i = 0; i < a.length; i++) {
      for (let j = 0; j < b.length; j++) {
        result[i + j] ^= multiplyGF(a[i], b[j]);
      }
    }
    return result;
  }
  function multiplyGF(a, b) {
    if (a === 0 || b === 0) return 0;
    return QRMath.gexp((QRMath.glog(a) + QRMath.glog(b)) % 255);
  }

  // --- Bit buffer ---
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype.put = function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
    }
  };
  BitBuffer.prototype.putBit = function (bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) this.buffer.push(0);
    if (bit) this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
    this.length++;
  };

  // --- QR RS Block table and helpers (data capacity) ---
  // Data from QR spec: [version][ecLevel] => array of RS blocks (count, dataCount)
  const RS_BLOCK_TABLE = (function () {
    // Only include necessary table entries for versions 1..40 and EC levels L,M,Q,H
    // Each entry: [ [count, dataCount], ... ]
    // Source: QR Code specification (condensed)
    // For brevity and reliability, include full table as numeric arrays (copied from standard tables).
    // Table format: version index 1..40, each has 4 arrays for L,M,Q,H.
    const table = [
      /* v1 */ [
        [1, 19], [1, 16], [1, 13], [1, 9]
      ],
      /* v2 */ [
        [1, 34], [1, 28], [1, 22], [1, 16]
      ],
      /* v3 */ [
        [1, 55], [1, 44], [2, 17], [2, 13]
      ],
      /* v4 */ [
        [1, 80], [2, 32], [2, 24], [4, 9]
      ],
      /* v5 */ [
        [1, 108], [2, 43], [2, 15, 2, 16], [2, 11, 2, 12]
      ],
      /* v6 */ [
        [2, 68], [4, 27], [4, 19], [4, 15]
      ],
      /* v7 */ [
        [2, 78], [4, 31], [2, 14, 4, 15], [4, 13, 1, 14]
      ],
      /* v8 */ [
        [2, 97], [2, 38, 2, 39], [4, 18, 2, 19], [4, 14, 2, 15]
      ],
      /* v9 */ [
        [2, 116], [3, 36, 2, 37], [4, 16, 4, 17], [4, 12, 4, 13]
      ],
      /* v10 */ [
        [2, 68, 2, 69], [4, 43, 1, 44], [6, 19, 2, 20], [6, 15, 2, 16]
      ],
      /* v11 */ [
        [4, 81], [1, 50, 4, 51], [4, 22, 4, 23], [4, 12, 4, 13, 1, 14]
      ],
      /* v12 */ [
        [2, 92, 2, 93], [6, 36, 2, 37], [4, 20, 6, 21], [4, 16, 6, 17]
      ],
      /* v13 */ [
        [4, 107], [8, 37, 1, 38], [8, 20, 4, 21], [12, 11, 4, 12]
      ],
      /* v14 */ [
        [3, 115, 1, 116], [4, 40, 5, 41], [11, 16, 5, 17], [11, 12, 5, 13]
      ],
      /* v15 */ [
        [5, 87, 1, 88], [5, 41, 5, 42], [5, 24, 7, 25], [11, 12, 7, 13]
      ],
      /* v16 */ [
        [5, 98, 1, 99], [7, 45, 3, 46], [15, 19, 2, 20], [3, 15, 13, 16]
      ],
      /* v17 */ [
        [1, 107, 5, 108], [10, 46, 1, 47], [1, 22, 15, 23], [2, 14, 17, 15]
      ],
      /* v18 */ [
        [5, 120, 1, 121], [9, 43, 4, 44], [17, 22, 1, 23], [2, 14, 19, 15]
      ],
      /* v19 */ [
        [3, 113, 4, 114], [3, 44, 11, 45], [17, 21, 4, 22], [9, 13, 16, 14]
      ],
      /* v20 */ [
        [3, 107, 5, 108], [3, 41, 13, 42], [15, 24, 5, 25], [15, 15, 10, 16]
      ],
      /* v21 */ [
        [4, 116, 4, 117], [17, 42], [17, 22, 6, 23], [19, 16, 6, 17]
      ],
      /* v22 */ [
        [2, 111, 7, 112], [17, 46], [7, 24, 16, 25], [34, 13]
      ],
      /* v23 */ [
        [4, 121, 5, 122], [4, 47, 14, 48], [11, 24, 14, 25], [16, 15, 14, 16]
      ],
      /* v24 */ [
        [6, 117, 4, 118], [6, 45, 14, 46], [11, 24, 16, 25], [30, 16, 2, 17]
      ],
      /* v25 */ [
        [8, 106, 4, 107], [8, 47, 13, 48], [7, 24, 22, 25], [22, 15, 13, 16]
      ],
      /* v26 */ [
        [10, 114, 2, 115], [19, 46, 4, 47], [28, 22, 6, 23], [33, 16, 4, 17]
      ],
      /* v27 */ [
        [8, 122, 4, 123], [22, 45, 3, 46], [8, 23, 26, 24], [12, 15, 28, 16]
      ],
      /* v28 */ [
        [3, 117, 10, 118], [3, 45, 23, 46], [4, 24, 31, 25], [11, 15, 31, 16]
      ],
      /* v29 */ [
        [7, 116, 7, 117], [21, 45, 7, 46], [1, 23, 37, 24], [19, 15, 26, 16]
      ],
      /* v30 */ [
        [5, 115, 10, 116], [19, 47, 10, 48], [15, 24, 25, 25], [23, 15, 25, 16]
      ],
      /* v31 */ [
        [13, 115, 3, 116], [2, 46, 29, 47], [42, 24, 1, 25], [23, 15, 28, 16]
      ],
      /* v32 */ [
        [17, 115], [10, 46, 23, 47], [10, 24, 35, 25], [19, 15, 35, 16]
      ],
      /* v33 */ [
        [17, 115, 1, 116], [14, 46, 21, 47], [29, 24, 19, 25], [11, 15, 46, 16]
      ],
      /* v34 */ [
        [13, 115, 6, 116], [14, 46, 23, 47], [44, 24, 7, 25], [59, 16, 1, 17]
      ],
      /* v35 */ [
        [12, 121, 7, 122], [12, 47, 26, 48], [39, 24, 14, 25], [22, 15, 41, 16]
      ],
      /* v36 */ [
        [6, 121, 14, 122], [6, 47, 34, 48], [46, 24, 10, 25], [2, 15, 64, 16]
      ],
      /* v37 */ [
        [17, 122, 4, 123], [29, 46, 14, 47], [49, 24, 10, 25], [24, 15, 46, 16]
      ],
      /* v38 */ [
        [4, 122, 18, 123], [13, 46, 32, 47], [48, 24, 14, 25], [42, 15, 32, 16]
      ],
      /* v39 */ [
        [20, 117, 4, 118], [40, 47, 7, 48], [43, 24, 22, 25], [10, 15, 67, 16]
      ],
      /* v40 */ [
        [19, 118, 6, 119], [18, 47, 31, 48], [34, 24, 34, 25], [20, 15, 61, 16]
      ]
    ];
    return table;
  })();

  function getRSBlocks(version, ecLevelChar) {
    const ecIndex = { L: 0, M: 1, Q: 2, H: 3 }[ecLevelChar];
    if (ecIndex === undefined) throw new Error("Invalid EC level: " + ecLevelChar);
    const entry = RS_BLOCK_TABLE[version - 1][ecIndex];
    // entry can be like [count,dataCount] or longer sequences
    const blocks = [];
    for (let i = 0; i < entry.length; i += 2) {
      const count = entry[i];
      const dataCount = entry[i + 1];
      for (let j = 0; j < count; j++) blocks.push({ dataCount: dataCount });
    }
    return blocks;
  }

  // --- Mode and encoding (we'll use byte mode for simplicity) ---
  function createDataBytes(version, ecLevelChar, text) {
    // Byte mode encoding (ISO-8859-1 / UTF-8 fallback)
    // Convert text to UTF-8 bytes
    const encoder = new TextEncoder();
    const data = Array.from(encoder.encode(text));

    // Determine capacity: total data codewords for version/ecLevel
    const rsBlocks = getRSBlocks(version, ecLevelChar);
    let totalDataCount = 0;
    for (const b of rsBlocks) totalDataCount += b.dataCount;

    // Build bit buffer
    const buffer = new BitBuffer();
    buffer.put(0b0100, 4); // byte mode
    // character count indicator length depends on version: 8 bits for versions 1-9, 16 for 10+
    const ccBits = version < 10 ? 8 : 16;
    buffer.put(data.length, ccBits);
    for (let i = 0; i < data.length; i++) buffer.put(data[i], 8);

    // Terminator
    const maxBits = totalDataCount * 8;
    if (buffer.length > maxBits) throw new Error("Data too long for version " + version);
    // pad with 0s to byte boundary
    while (buffer.length % 8 !== 0) buffer.putBit(false);
    // pad bytes 0xec,0x11
    const padBytes = [0xec, 0x11];
    let i = 0;
    while (Math.ceil(buffer.length / 8) < totalDataCount) {
      buffer.put(padBytes[i % 2], 8);
      i++;
    }
    // return array of data codewords
    const bytes = [];
    for (let i = 0; i < totalDataCount; i++) {
      const byte = buffer.buffer[i] || 0;
      bytes.push(byte & 0xff);
    }
    return { bytes: bytes, rsBlocks: rsBlocks };
  }

  // --- Error correction coding (Reed-Solomon) ---
  function createCodewords(version, ecLevelChar, dataBytes, rsBlocks) {
    // Split data bytes into block groups according to RS block structure
    // The RS_BLOCK_TABLE entries sometimes specify groups with different data lengths.
    // We need to reconstruct the block structure: for a given version/ecLevel, the RS_BLOCK_TABLE
    // entries are already expanded into blocks with dataCount only (see getRSBlocks).
    const blockCount = rsBlocks.length;
    // Determine number of data codewords per block (some blocks may differ by 1)
    const dataCounts = rsBlocks.map(b => b.dataCount);
    const maxDataCount = Math.max(...dataCounts);
    // Distribute data bytes into blocks
    const blocks = [];
    let offset = 0;
    for (let i = 0; i < blockCount; i++) {
      const dc = dataCounts[i];
      const blockData = dataBytes.slice(offset, offset + dc);
      offset += dc;
      blocks.push({ data: blockData });
    }
    // For each block, compute ECC
    // ECC length = total codewords per block - dataCount
    // total codewords per block = (totalDataCount + totalEccCount) / blockCount (but easier: use RS generator degree from table)
    // We can compute ECC length by using version/ecLevel total codewords minus data codewords.
    const totalCodewords = getTotalCodewords(version);
    const totalDataCodewords = dataBytes.length;
    const totalEccCodewords = totalCodewords - totalDataCodewords;
    const eccPerBlock = Math.floor(totalEccCodewords / blockCount);

    for (let i = 0; i < blocks.length; i++) {
      const dc = blocks[i].data.slice();
      const ecc = reedSolomonEncode(dc, eccPerBlock);
      blocks[i].ecc = ecc;
    }

    // Interleave data and ecc into final codeword sequence
    const maxDataLen = Math.max(...blocks.map(b => b.data.length));
    const maxEccLen = Math.max(...blocks.map(b => b.ecc.length));
    const codewords = [];
    for (let i = 0; i < maxDataLen; i++) {
      for (let j = 0; j < blocks.length; j++) {
        if (i < blocks[j].data.length) codewords.push(blocks[j].data[i]);
      }
    }
    for (let i = 0; i < maxEccLen; i++) {
      for (let j = 0; j < blocks.length; j++) {
        if (i < blocks[j].ecc.length) codewords.push(blocks[j].ecc[i]);
      }
    }
    return codewords;
  }

  function reedSolomonEncode(data, ecLength) {
    const gen = createGeneratorPolynomial(ecLength);
    const ec = new Array(ecLength).fill(0);
    for (let i = 0; i < data.length; i++) {
      const factor = data[i] ^ ec[0];
      ec.shift();
      ec.push(0);
      if (factor !== 0) {
        for (let j = 0; j < gen.length; j++) {
          ec[j] ^= multiplyGF(gen[j], factor);
        }
      }
    }
    return ec;
  }

  // --- Utility: total codewords per version (from spec) ---
  const TOTAL_CODEWORDS_TABLE = [
    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
  ];
  function getTotalCodewords(version) {
    return TOTAL_CODEWORDS_TABLE[version - 1];
  }

  // --- Matrix placement helpers ---
  function createEmptyMatrix(size) {
    const m = new Array(size);
    for (let r = 0; r < size; r++) {
      m[r] = new Array(size).fill(null);
    }
    return m;
  }

  function placeFinderPattern(matrix, r, c) {
    for (let dr = -1; dr <= 7; dr++) {
      for (let dc = -1; dc <= 7; dc++) {
        const rr = r + dr;
        const cc = c + dc;
        if (rr < 0 || rr >= matrix.length || cc < 0 || cc >= matrix.length) continue;
        if ((0 <= dr && dr <= 6 && (dc === 0 || dc === 6)) ||
            (0 <= dc && dc <= 6 && (dr === 0 || dr === 6)) ||
            (2 <= dr && dr <= 4 && 2 <= dc && dc <= 4)) {
          matrix[rr][cc] = 1;
        } else {
          matrix[rr][cc] = 0;
        }
      }
    }
  }

  function placeAlignmentPattern(matrix, r, c) {
    for (let dr = -2; dr <= 2; dr++) {
      for (let dc = -2; dc <= 2; dc++) {
        const rr = r + dr;
        const cc = c + dc;
        if (rr < 0 || rr >= matrix.length || cc < 0 || cc >= matrix.length) continue;
        if (Math.max(Math.abs(dr), Math.abs(dc)) === 2 || (dr === 0 && dc === 0)) {
          matrix[rr][cc] = 1;
        } else {
          matrix[rr][cc] = 0;
        }
      }
    }
  }

  function getAlignmentPatternPositions(version) {
    if (version === 1) return [];
    const posCount = Math.floor(version / 7) + 2;
    const size = version * 4 + 17;
    const step = posCount === 2 ? size - 13 : Math.ceil((size - 13) / (posCount - 1));
    const positions = [];
    let pos = 6;
    for (let i = 0; i < posCount - 1; i++) {
      positions.push(pos);
      pos += step;
    }
    positions.push(size - 7);
    return positions;
  }

  function isReserved(matrix, r, c) {
    // Finder areas and timing lines and format info areas
    const size = matrix.length;
    if (r < 9 && c < 9) return true;
    if (r < 9 && c >= size - 8) return true;
    if (r >= size - 8 && c < 9) return true;
    if (r === 6 || c === 6) return true;
    return false;
  }

  // --- Mask functions (0..7) ---
  const MASK_FUNCS = [
    (r, c) => (r + c) % 2 === 0,
    (r, c) => r % 2 === 0,
    (r, c) => c % 3 === 0,
    (r, c) => (r + c) % 3 === 0,
    (r, c) => (Math.floor(r / 2) + Math.floor(c / 3)) % 2 === 0,
    (r, c) => ((r * c) % 2) + ((r * c) % 3) === 0,
    (r, c) => (((r * c) % 2) + ((r * c) % 3)) % 2 === 0,
    (r, c) => (((r + c) % 2) + ((r * c) % 3)) % 2 === 0
  ];

  // --- Format bits (error correction + mask) generator ---
  function getFormatBits(ecLevelChar, maskPattern) {
    const ecCode = { L: 1, M: 0, Q: 3, H: 2 }[ecLevelChar];
    let formatInfo = (ecCode << 3) | maskPattern;
    // BCH code (15,5) generator 0x537
    let g = formatInfo << 10;
    const poly = 0x537;
    for (let i = 14; i >= 10; i--) {
      if ((g >>> i) & 1) g ^= poly << (i - 10);
    }
    const bits = ((formatInfo << 10) | g) ^ 0x5412;
    return bits & 0x7fff;
  }

  // --- Version information bits (for versions >=7) ---
  function getVersionBits(version) {
    // BCH code (18,6) generator 0x1f25
    let v = version << 12;
    let g = v;
    const poly = 0x1f25;
    for (let i = 17; i >= 12; i--) {
      if ((g >>> i) & 1) g ^= poly << (i - 12);
    }
    return ((version << 12) | g) & 0x3ffff;
  }

  // --- Place data bits into matrix ---
  function placeDataBits(matrix, codewords) {
    const size = matrix.length;
    let row = size - 1;
    let col = size - 1;
    let dirUp = true;
    let bitIndex = 0;
    const totalBits = codewords.length * 8;
    function nextBit() {
      if (bitIndex >= totalBits) return 0;
      const byteIndex = Math.floor(bitIndex / 8);
      const bitInByte = 7 - (bitIndex % 8);
      bitIndex++;
      return (codewords[byteIndex] >>> bitInByte) & 1;
    }
    while (col > 0) {
      if (col === 6) col--;
      for (let i = 0; i < size; i++) {
        const r = dirUp ? size - 1 - i : i;
        for (let cOff = 0; cOff < 2; cOff++) {
          const c = col - cOff;
          if (matrix[r][c] !== null) continue;
          matrix[r][c] = nextBit();
        }
      }
      col -= 2;
      dirUp = !dirUp;
    }
  }

  // --- Apply mask and compute penalty score ---
  function applyMask(matrix, maskFunc) {
    const size = matrix.length;
    const masked = createEmptyMatrix(size);
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (matrix[r][c] === null) masked[r][c] = null;
        else {
          const bit = matrix[r][c];
          masked[r][c] = maskFunc(r, c) ? (bit ^ 1) : bit;
        }
      }
    }
    return masked;
  }

  function computePenalty(matrix) {
    const size = matrix.length;
    let penalty = 0;
    // Rule 1: consecutive modules in row/col
    for (let r = 0; r < size; r++) {
      let runColor = matrix[r][0];
      let runLen = 1;
      for (let c = 1; c < size; c++) {
        if (matrix[r][c] === runColor) runLen++;
        else {
          if (runLen >= 5) penalty += 3 + (runLen - 5);
          runColor = matrix[r][c];
          runLen = 1;
        }
      }
      if (runLen >= 5) penalty += 3 + (runLen - 5);
    }
    for (let c = 0; c < size; c++) {
      let runColor = matrix[0][c];
      let runLen = 1;
      for (let r = 1; r < size; r++) {
        if (matrix[r][c] === runColor) runLen++;
        else {
          if (runLen >= 5) penalty += 3 + (runLen - 5);
          runColor = matrix[r][c];
          runLen = 1;
        }
      }
      if (runLen >= 5) penalty += 3 + (runLen - 5);
    }
    // Rule 2: 2x2 blocks
    for (let r = 0; r < size - 1; r++) {
      for (let c = 0; c < size - 1; c++) {
        const v = matrix[r][c];
        if (v === matrix[r][c + 1] && v === matrix[r + 1][c] && v === matrix[r + 1][c + 1]) penalty += 3;
      }
    }
    // Rule 3: patterns similar to finder pattern in rows/cols
    const pattern1 = [1,0,1,1,1,0,1,0,0,0,0];
    const pattern2 = [0,0,0,0,1,0,1,1,1,0,1];
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size - 10; c++) {
        let match1 = true, match2 = true;
        for (let k = 0; k < 11; k++) {
          if (matrix[r][c + k] !== pattern1[k]) match1 = false;
          if (matrix[r][c + k] !== pattern2[k]) match2 = false;
        }
        if (match1 || match2) penalty += 40;
      }
    }
    for (let c = 0; c < size; c++) {
      for (let r = 0; r < size - 10; r++) {
        let match1 = true, match2 = true;
        for (let k = 0; k < 11; k++) {
          if (matrix[r + k][c] !== pattern1[k]) match1 = false;
          if (matrix[r + k][c] !== pattern2[k]) match2 = false;
        }
        if (match1 || match2) penalty += 40;
      }
    }
    // Rule 4: balance of dark modules
    let dark = 0;
    for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) if (matrix[r][c] === 1) dark++;
    const total = size * size;
    const k = Math.abs(Math.floor((dark * 100 / total) - 50) / 5);
    penalty += k * 10;
    return penalty;
  }

  // --- Build final matrix for a given version and mask ---
  function buildMatrix(version, ecLevelChar, codewords, maskPattern) {
    const size = version * 4 + 17;
    const matrix = createEmptyMatrix(size);
    // place finder patterns
    placeFinderPattern(matrix, 0, 0);
    placeFinderPattern(matrix, size - 7, 0);
    placeFinderPattern(matrix, 0, size - 7);
    // place separators (already handled by finder pattern placement setting surrounding to 0)
    // place timing patterns
    for (let i = 8; i < size - 8; i++) {
      if (matrix[6][i] === null) matrix[6][i] = (i % 2 === 0) ? 1 : 0;
      if (matrix[i][6] === null) matrix[i][6] = (i % 2 === 0) ? 1 : 0;
    }
    // place alignment patterns
    const alignPos = getAlignmentPatternPositions(version);
    for (let i = 0; i < alignPos.length; i++) {
      for (let j = 0; j < alignPos.length; j++) {
        const r = alignPos[i], c = alignPos[j];
        // skip if overlaps finder
        if ((r === 6 && (c === 6 || c === size - 7)) || (r === size - 7 && c === 6)) continue;
        placeAlignmentPattern(matrix, r, c);
      }
    }
    // reserve format info areas (set to 0 temporarily)
    for (let i = 0; i < 9; i++) {
      if (matrix[8][i] === null) matrix[8][i] = 0;
      if (matrix[i][8] === null) matrix[i][8] = 0;
      if (matrix[8][size - 1 - i] === null) matrix[8][size - 1 - i] = 0;
      if (matrix[size - 1 - i][8] === null) matrix[size - 1 - i][8] = 0;
    }
    // place version info if needed (versions >=7)
    if (version >= 7) {
      const vb = getVersionBits(version);
      for (let i = 0; i < 18; i++) {
        const bit = (vb >>> i) & 1;
        const r = Math.floor(i / 3);
        const c = i % 3;
        matrix[size - 11 + c][r] = bit;
        matrix[r][size - 11 + c] = bit;
      }
    }
    // place data bits
    placeDataBits(matrix, codewords);
    // apply mask
    const masked = applyMask(matrix, MASK_FUNCS[maskPattern]);
    // place format bits
    const formatBits = getFormatBits(ecLevelChar, maskPattern);
    // top-left format
    for (let i = 0; i < 8; i++) {
      const bit = (formatBits >>> i) & 1;
      // (8,i)
      if (i !== 6) masked[8][i] = bit;
      // (i,8)
      if (i !== 6) masked[i][8] = bit;
    }
    // other format positions
    for (let i = 0; i < 7; i++) {
      const bit = (formatBits >>> (14 - i)) & 1;
      masked[8][size - 1 - i] = bit;
      masked[size - 1 - i][8] = bit;
    }
    // set dark module
    masked[size - 8][8] = 1;
    return masked;
  }

  // --- Choose best mask by penalty ---
  function chooseBestMask(version, ecLevelChar, codewords) {
    let bestMask = 0;
    let bestScore = Infinity;
    let bestMatrix = null;
    for (let mask = 0; mask < 8; mask++) {
      const matrix = buildMatrix(version, ecLevelChar, codewords, mask);
      const score = computePenalty(matrix);
      if (score < bestScore) {
        bestScore = score;
        bestMask = mask;
        bestMatrix = matrix;
      }
    }
    return { mask: bestMask, matrix: bestMatrix };
  }

  // --- Auto-select version based on data length and EC level ---
  function selectVersionForData(text, ecLevelChar) {
    // Try versions 1..40 and pick first that fits
    for (let version = 1; version <= 40; version++) {
      try {
        const { bytes } = createDataBytes(version, ecLevelChar, text);
        // if no exception, it fits
        return version;
      } catch (e) {
        // continue
      }
    }
    throw new Error("Data too long to encode in QR Code (max version 40)");
  }

  // --- Main flow: build QR matrix for text ---
  function buildQrMatrix(text, ecLevelChar) {
    const version = selectVersionForData(text, ecLevelChar);
    const { bytes: dataBytes, rsBlocks } = createDataBytes(version, ecLevelChar, text);
    const codewords = createCodewords(version, ecLevelChar, dataBytes, rsBlocks);
    const { mask, matrix } = chooseBestMask(version, ecLevelChar, codewords);
    return { matrix: matrix, version: version, mask: mask };
  }

  // --- Render matrix to SVG ---
  function renderSvg(matrix, scale, margin) {
    const size = matrix.length;
    const moduleSize = scale;
    const quiet = margin;
    const svgSize = (size + quiet * 2) * moduleSize;
    let rects = "";
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (matrix[r][c] === 1) {
          const x = (c + quiet) * moduleSize;
          const y = (r + quiet) * moduleSize;
          rects += `<rect x="${x}" y="${y}" width="${moduleSize}" height="${moduleSize}" fill="#000"/>`;
        }
      }
    }
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgSize} ${svgSize}" width="${svgSize}" height="${svgSize}" shape-rendering="crispEdges">${rects}</svg>`;
    return svg;
  }

  // --- Execute ---
  if (typeof text !== "string") text = String(text);
  if (!['L','M','Q','H'].includes(ecLevel)) ecLevel = 'M';
  // Build matrix (may throw if too long)
  const { matrix } = buildQrMatrix(text, ecLevel);
  return renderSvg(matrix, scale, margin);
}


  // --- Form <> data wiring -----------------------------------------
  function loadToForm(key, cfg) {
    $("codeKey").value = key;
    $("actionType").value = cfg.type;
    $("targetUrl").value = cfg.targetUrl || "";
    $("extraParams").value = cfg.extraParams ? JSON.stringify(cfg.extraParams, null, 2) : "";
    $("downloadUrl").value = cfg.downloadUrl || "";
    $("downloadName").value = cfg.downloadName || "";
    $("displayData").value = cfg.displayData || "";
    onActionTypeChange();
    renderQrForKey(key);
    setMessage("Loaded code '" + key + "' into form.");
  }

  function onActionTypeChange() {
    const type = $("actionType").value;
    show("field_targetUrl", type === "redirect" || type === "redirectWithParams");
    show("field_params", type === "redirectWithParams");
    show("field_download", type === "download");
    show("field_display", type === "display");
  }

  function currentBaseUrl() {
    return window.location.origin + window.location.pathname.replace(/[#?].*$/, "");
  }

  function renderQrForKey(key) {
    if (!key) {
      $("qrContainer").innerHTML = "";
      $("qrUrl").textContent = "";
      show("downloadSvgBtn", false);
      return;
    }
    const url = currentBaseUrl() + "?code=" + encodeURIComponent(key);
    $("qrUrl").textContent = url;

    let svg = "";
    try {
      svg = makeQrSvg(url, 4);
      $("qrContainer").innerHTML = svg;
      show("downloadSvgBtn", true);
      $("downloadSvgBtn").onclick = function () {
        const blob = new Blob([svg], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "qr-" + key + ".svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      };
    } catch (e) {
      $("qrContainer").textContent = "Could not render QR: " + e.message;
      show("downloadSvgBtn", false);
    }
  }

  function saveFromForm() {
    const key = $("codeKey").value.trim();
    if (!key) {
      setMessage("Key is required.");
      return;
    }
    const type = $("actionType").value;
    const codes = loadCodes();
    const cfg = { type: type };

    if (type === "redirect" || type === "redirectWithParams") {
      const url = $("targetUrl").value.trim();
      if (!url) {
        setMessage("Target URL is required for redirect.");
        return;
      }
      cfg.targetUrl = url;
      if (type === "redirectWithParams") {
        const raw = $("extraParams").value.trim();
        if (raw) {
          try {
            const obj = JSON.parse(raw);
            if (typeof obj !== "object" || Array.isArray(obj) || obj === null) {
              setMessage("Extra parameters must be a JSON object.");
              return;
            }
            cfg.extraParams = obj;
          } catch (e) {
            setMessage("Invalid JSON in extra parameters: " + e.message);
            return;
          }
        } else {
          cfg.extraParams = {};
        }
      }
    } else if (type === "download") {
      const dUrl = $("downloadUrl").value.trim();
      if (!dUrl) {
        setMessage("Download URL/data is required.");
        return;
      }
      cfg.downloadUrl = dUrl;
      cfg.downloadName = $("downloadName").value.trim() || "download";
    } else if (type === "display") {
      cfg.displayData = $("displayData").value;
    }

    codes[key] = cfg;
    saveCodes(codes);
    updateCodeList(codes);
    renderQrForKey(key);
    setMessage("Saved code '" + key + "'.");
  }

  // --- Action execution ---------------------------------------------
  function executeAction(key, cfg) {
    if (!cfg) {
      setMessage("No configuration found for code '" + key + "'.");
      show("adminUI", true);
      return;
    }
    const type = cfg.type;
    if (type === "redirect") {
      setMessage("Redirecting...");
      window.location.href = cfg.targetUrl;
    } else if (type === "redirectWithParams") {
      setMessage("Redirecting with parameters...");
      const url = new URL(cfg.targetUrl, window.location.href);
      const params = cfg.extraParams || {};
      Object.keys(params).forEach(k => {
        url.searchParams.set(k, params[k]);
      });
      // Also forward any existing query parameters (except 'code')
      const current = new URL(window.location.href);
      current.searchParams.forEach((v, k) => {
        if (k === "code") return;
        if (!url.searchParams.has(k)) {
          url.searchParams.set(k, v);
        }
      });
      window.location.href = url.toString();
    } else if (type === "download") {
      setMessage("Starting download...");
      const a = document.createElement("a");
      a.href = cfg.downloadUrl;
      a.download = cfg.downloadName || "download";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } else if (type === "display") {
      setMessage("Displaying content for code '" + key + "'.");
      show("displayArea", true);
      $("displayContent").innerHTML = cfg.displayData || "(no content)";
    } else {
      setMessage("Unknown action type for code '" + key + "'.");
    }
  }

  // --- Main entry logic ---------------------------------------------
  const params = new URLSearchParams(window.location.search);
  const codeKey = params.get("code");
  const codes = loadCodes();

  if (codeKey) {
    // handle QR action
    show("adminUI", false);
    executeAction(codeKey, codes[codeKey]);
  } else {
    // show admin interface
    show("adminUI", true);
    updateCodeList(codes);
    setMessage("Admin mode: create and manage dynamic QR codes.");
    onActionTypeChange();
    // bind events
    $("actionType").addEventListener("change", onActionTypeChange);
    $("saveCode").addEventListener("click", saveFromForm);
    $("codeKey").addEventListener("input", function () {
      renderQrForKey(this.value.trim());
    });
  }
})(); // end dynamicQRRouter IIFE
</script>
</body>
</html>

