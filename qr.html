<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dynamic QR Router</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 1.5rem; }
    h1, h2 { margin-top: 0; }
    label { display: block; margin-top: 0.75rem; font-weight: 600; }
    input, select, textarea { width: 100%; max-width: 600px; padding: 0.35rem 0.5rem; margin-top: 0.25rem; font-size: 0.95rem; }
    button { margin-top: 0.8rem; padding: 0.4rem 0.8rem; font-size: 0.95rem; cursor: pointer; }
    .row { display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start; }
    .col { flex: 1 1 260px; min-width: 260px; }
    .small { font-size: 0.8rem; color: #555; }
    pre { background:#f4f4f4; padding:0.5rem; overflow:auto; max-width: 600px; }
    #message { margin-top: 0.5rem; color: #333; font-size: 0.9rem; }
    #qrContainer svg { border:1px solid #ccc; margin-top:0.5rem; }
    table { border-collapse: collapse; margin-top:0.75rem; }
    th, td { border:1px solid #ccc; padding:0.25rem 0.5rem; font-size:0.8rem; }
    th { background:#f8f8f8; }
    .pill { display:inline-block; padding:0.1rem 0.4rem; border-radius:999px; font-size:0.7rem; background:#eee; }
    .hidden { display:none; }
  </style>
</head>
<body>
<h1>Dynamic QR Router</h1>
<div id="message"></div>

<div id="adminUI" class="hidden">
  <div class="row">
    <div class="col">
      <h2>Create / update QR code</h2>
      <label>
        QR key (e.g. "promo1")
        <input id="codeKey" placeholder="short identifier used in ?code=..." />
      </label>

      <label>
        Action type
        <select id="actionType">
          <option value="redirect">Redirect to URL</option>
          <option value="redirectWithParams">Redirect with URL parameters</option>
          <option value="download">Trigger download (data URL or http(s) URL)</option>
          <option value="display">Display data</option>
        </select>
      </label>

      <div id="field_targetUrl">
        <label>
          Target URL
          <input id="targetUrl" placeholder="https://example.com/page" />
        </label>
      </div>

      <div id="field_params" class="hidden">
        <label>
          Extra URL parameters (JSON object)
          <textarea id="extraParams" rows="3" placeholder='{"utm_source":"qr","campaign":"spring"}'></textarea>
        </label>
      </div>

      <div id="field_download" class="hidden">
        <label>
          Download URL or data URI
          <input id="downloadUrl" placeholder="https://example.com/file.pdf or data:...;base64,..." />
        </label>
        <label>
          Suggested filename
          <input id="downloadName" placeholder="file.pdf" />
        </label>
      </div>

      <div id="field_display" class="hidden">
        <label>
          Display text / data (HTML allowed)
          <textarea id="displayData" rows="4" placeholder="This is some content shown for this QR code."></textarea>
        </label>
      </div>

      <button id="saveCode">Save / update code</button>
      <div class="small">
        Codes are stored in your browser only (localStorage). No server is called.
      </div>

      <h3 style="margin-top:1.5rem;">Generated QR (for this key)</h3>
      <div class="small">
        Scalable SVG, encodes this page with <code>?code=&lt;your-key&gt;</code>.
      </div>
      <pre id="qrUrl"></pre>
      <div id="qrContainer"></div>
      <button id="downloadSvgBtn" class="hidden">Download SVG</button>
    </div>

    <div class="col">
      <h2>Existing codes</h2>
      <div class="small">Click a key to load it into the editor.</div>
      <div id="codeList"></div>
      <hr>
      <textarea id="updatedJSON" readonly></textarea>
    </div>
  </div>
</div>

<div id="displayArea" class="hidden">
  <h2>QR content</h2>
  <div id="displayContent"></div>
</div>

<script>
/*
  Single function orchestrating everything:
  - parse query and storage
  - execute actions (redirect, download, display)
  - render admin UI when no ?code=
  - generate SVG QR (no external deps, no network)
*/
(function dynamicQRRouter() {
  "use strict";

  // --- tiny helpers (still inside the IIFE) -----------------
  function $(id) { return document.getElementById(id); }

  function loadCodes() {
    let codes = {};
    try {
      const raw = localStorage.getItem("dynamicQrCodes") || "{}";
      const _defaults = {"test":{"type":"redirect","targetUrl":"http://"},"test1":{"type":"redirectWithParams","targetUrl":"http://1","extraParams":{"test":1}},"test2":{"type":"download","downloadUrl":"http://2","downloadName":"2.pdf"},"test3":{"type":"display","displayData":"333"}};
      codes= {..._defaults, ...JSON.parse(raw)};
    } catch (e) {
      //return {};
    }
    document.getElementById("updatedJSON").value = JSON.stringify(codes);
    return codes;
  }

  function saveCodes(codes) {
    localStorage.setItem("dynamicQrCodes", JSON.stringify(codes));
    document.getElementById("updatedJSON").value = JSON.stringify(codes);
  }

  function updateCodeList(codes) {
    const container = $("codeList");
    container.innerHTML = "";
    const keys = Object.keys(codes).sort();
    if (!keys.length) {
      container.textContent = "No codes yet.";
      return;
    }
    const table = document.createElement("table");
    const thead = document.createElement("thead");
    thead.innerHTML = "<tr><th>Key</th><th>Action</th></tr>";
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    keys.forEach(k => {
      const tr = document.createElement("tr");
      const tdKey = document.createElement("td");
      const link = document.createElement("button");
      link.textContent = k;
      link.style.border = "none";
      link.style.background = "none";
      link.style.padding = "0";
      link.style.cursor = "pointer";
      link.style.color = "#0366d6";
      link.onclick = function () {
        loadToForm(k, codes[k]);
      };
      tdKey.appendChild(link);
      const tdAction = document.createElement("td");
      tdAction.innerHTML = "<span class='pill'>" + codes[k].type + "</span>";
      tr.appendChild(tdKey);
      tr.appendChild(tdAction);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  function setMessage(msg) {
    $("message").textContent = msg || "";
  }

  function show(elOrId, show) {
    const el = typeof elOrId === "string" ? $(elOrId) : elOrId;
    if (!el) return;
    el.classList[show ? "remove" : "add"]("hidden");
  }

  // --- QR generation (minimal, numeric+alnum, SVG) -----------------
  // For simplicity this uses a very small, fixed-size QR implementation
  // (version 2, ECC level L-like behaviour; not production-grade but fine for short URLs).
  // Encodes input in byte mode and draws modules as <rect>s.

var qrcodegen = qrcodegen || {};

(function (qrcodegen) {
  const RS_DIV_CACHE = new Map();

  function assert(cond, msg = "Assertion error") {
    if (!cond) throw new Error(msg);
  }
  function getBit(x, i) {
    return ((x >>> i) & 1) !== 0;
  }
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || (val >>> len) !== 0) throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; --i) bb.push((val >>> i) & 1);
  }
  function resolveContainer(c) { if (!c) return null; if (typeof c === 'string') return document.querySelector(c); if (c instanceof Element) return c; return null; }
  function displayQr(text, opts = {}) {
    if (text === "") {return;}

    const DEFAULTS = {
      download:false,
      dataColour:'#000',
      bgColour:'#fff',
      ecl: qrcodegen.QrCode.Ecc.MEDIUM,
      display:false,
      container: null, // selector or Element
      displayScale: 5,
      displayQuiet: 4,
      outputType: 'canvas',//svg or canvas
      minVersion: 1,
      maxVersion: 40,
      mask: -1,
      boostEcl:true
    };
    const options = { ...DEFAULTS, ...opts };
    const qr = qrcodegen.QrCode.encodeText(text, options.ecl, options.minVersion, options.maxVersion, options.mask, options.boostEcl);

    // Convert matrix to canvas
    const matrix = qr.modules;
    const size = matrix.length;

    // Rendering parameters
    const scale = options.displayScale;           // pixels per module
    const quiet = options.displayQuiet;           // quiet zone modules
    const moduleSize = Math.max(1, Math.floor(scale));
    const q = Math.max(4, Math.floor(quiet));
    const displaySize = (size + q * 2) * moduleSize;

    // Create canvas
    const canvas = document.createElement("canvas");
    canvas.width = displaySize;
    canvas.height = displaySize;
    canvas.style.imageRendering = "pixelated";
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = options.bgColour;
    ctx.fillRect(0, 0, displaySize, displaySize);

    // Draw modules
    ctx.fillStyle = options.dataColour;
    let rects = `<rect x="0" y="0" width="${displaySize}" height="${displaySize}" fill="${options.bgColour}"/>`;
    for (let r = 0; r < size; r += 1) {
        for (let c = 0; c < size; c += 1) {
            if(matrix[r][c] === 1){
              const x = (c + q) * moduleSize;
              const y = (r + q) * moduleSize;
              ctx.fillRect(x, y, moduleSize, moduleSize);
              rects += `<rect x="${x}" y="${y}" width="${moduleSize}" height="${moduleSize}" fill="${options.dataColour}"/>`;
            }
        }
    }
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${displaySize} ${displaySize}" width="${displaySize}" height="${displaySize}" shape-rendering="crispEdges">${rects}</svg>`;
    const svgContainer = document.createElement('div');
    svgContainer.innerHTML = svg;

    // Append canvas to body (or replace with your own container)
    if (typeof document !== "undefined" && document.body && options.display) {
      const outputType = options.outputType === 'canvas' ? canvas : svgContainer;
      const inlineContainer = resolveContainer(options.container);
      if (inlineContainer) {
        inlineContainer.appendChild(outputType);
      } else {
        document.body.appendChild(outputType);
      }
    }

    const returnItem = {qr,text,options,images:{svg,canvas:canvas.toDataURL()}};
    if(options.download){
      downloadQr(returnItem);
    }
    return returnItem;
  }

  qrcodegen.displayQr = displayQr;
  function downloadQr(returnItem){
    var svgData = returnItem.images.svg;
    var svgBlob = new Blob([svgData], {type:"image/svg+xml;charset=utf-8"});
    var svgUrl = URL.createObjectURL(svgBlob);
    var downloadLink = document.createElement("a");
    downloadLink.href = returnItem.options.outputType==='canvas'?returnItem.images.canvas:svgUrl;
    downloadLink.download = "QR_"+encodeURI(returnItem.text).substring(0, 15)+".svg";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  }

  class QrCode {
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION) throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");

      this.size = version * 4 + 17;
      this.modules = new Array(this.size);
      this.isFunction = new Array(this.size);
      for (let y = 0; y < this.size; ++y) {
        this.modules[y] = new Uint8Array(this.size);
        this.isFunction[y] = new Uint8Array(this.size);
      }

      this.drawFunctionPatterns();

      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);

      if (msk === -1) {
        let minPenalty = Number.POSITIVE_INFINITY;
        for (let i = 0; i < 8; ++i) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i); // revert
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
    }

    static encodeText(text, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      const segs = qrcodegen.QrSegment.makeSegments(text);
      return QrCode.encodeSegments(segs, ecl, minVersion, maxVersion, mask, boostEcl);
    }

    static encodeBinary(data, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      const seg = qrcodegen.QrSegment.makeBytes(data);
      return QrCode.encodeSegments([seg], ecl, minVersion, maxVersion, mask, boostEcl);
    }

    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7) {
        throw new RangeError("Invalid value");
      }

      let version, dataUsedBits;
      for (version = minVersion;; ++version) {
        const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
        const usedBits = qrcodegen.QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion) throw new RangeError("Data too long");
      }

      for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8) {
          ecl = newEcl;
        }
      }

      const bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
        const data = seg.getData();
        for (let i = 0; i < data.length; ++i) bb.push(data[i]);
      }
      assert(bb.length === dataUsedBits);

      const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
      assert(bb.length <= dataCapacityBits);

      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - (bb.length % 8)) % 8, bb);
      assert(bb.length % 8 === 0);

      for (let padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11) {
        appendBits(padByte, 8, bb);
      }

      const dataCodewords = new Array(Math.ceil(bb.length / 8));
      for (let i = 0; i < dataCodewords.length; ++i) dataCodewords[i] = 0;
      for (let i = 0; i < bb.length; ++i) {
        dataCodewords[i >>> 3] |= bb[i] << (7 - (i & 7));
      }

      return new QrCode(version, ecl, dataCodewords, mask);
    }

    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x] === 1;
    }

    drawFunctionPatterns() {
      const s = this.size;
      for (let i = 0; i < s; ++i) {
        this.setFunctionModule(6, i, (i % 2) === 0);
        this.setFunctionModule(i, 6, (i % 2) === 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(s - 4, 3);
      this.drawFinderPattern(3, s - 4);

      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; ++i) {
        for (let j = 0; j < numAlign; ++j) {
          if (!((i === 0 && j === 0) || (i === 0 && j === numAlign - 1) || (i === numAlign - 1 && j === 0))) {
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
          }
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }

    drawFormatBits(mask) {
      const data = (this.errorCorrectionLevel.formatBits << 3) | mask;
      let rem = data;
      for (let i = 0; i < 10; ++i) rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
      const bits = ((data << 10) | rem) ^ 0x5412;
      assert((bits >>> 15) === 0);

      for (let i = 0; i <= 5; ++i) this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; ++i) this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; ++i) this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; ++i) this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }

    drawVersion() {
      if (this.version < 7) return;
      let rem = this.version;
      for (let i = 0; i < 12; ++i) rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);
      const bits = (this.version << 12) | rem;
      assert((bits >>> 18) === 0);
      for (let i = 0; i < 18; ++i) {
        const color = getBit(bits, i);
        const a = this.size - 11 + (i % 3);
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }

    drawFinderPattern(cx, cy) {
      const s = this.size;
      for (let dy = -4; dy <= 4; ++dy) {
        for (let dx = -4; dx <= 4; ++dx) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = cx + dx, yy = cy + dy;
          if (0 <= xx && xx < s && 0 <= yy && yy < s) {
            this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4);
          }
        }
      }
    }

    drawAlignmentPattern(cx, cy) {
      for (let dy = -2; dy <= 2; ++dy) {
        for (let dx = -2; dx <= 2; ++dx) {
          this.setFunctionModule(cx + dx, cy + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1);
        }
      }
    }

    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark ? 1 : 0;
      this.isFunction[y][x] = 1;
    }

    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length !== QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");

      const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - (rawCodewords % numBlocks);
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);

      const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);

      const blocks = new Array(numBlocks);
      for (let i = 0, k = 0; i < numBlocks; ++i) {
        const datLen = shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1);
        const dat = data.slice(k, k + datLen);
        k += datLen;
        const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks) dat.push(0);
        blocks[i] = dat.concat(ecc);
      }

      const result = [];
      const blockLen = blocks[0].length;
      for (let i = 0; i < blockLen; ++i) {
        for (let j = 0; j < blocks.length; ++j) {
          if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) {
            result.push(blocks[j][i]);
          }
        }
      }
      assert(result.length === rawCodewords);
      return result;
    }

    drawCodewords(data) {
      if (data.length !== Math.floor(QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        let col = right;
        if (right === 6) col = 5;
        for (let vert = 0; vert < this.size; ++vert) {
          for (let j = 0; j < 2; ++j) {
            const x = col - j;
            const upward = (((right + 1) & 2) === 0);
            const y = upward ? (this.size - 1 - vert) : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = ((data[i >>> 3] >>> (7 - (i & 7))) & 1);
              ++i;
            }
          }
        }
      }
      assert(i === data.length * 8);
    }

    applyMask(mask) {
      if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
      const s = this.size;
      const modules = this.modules;
      const isFunc = this.isFunction;
      for (let y = 0; y < s; ++y) {
        const row = modules[y];
        const funcRow = isFunc[y];
        for (let x = 0; x < s; ++x) {
          if (funcRow[x]) continue;
          let invert;
          switch (mask) {
            case 0: invert = ((x + y) & 1) === 0; break;
            case 1: invert = (y & 1) === 0; break;
            case 2: invert = (x % 3) === 0; break;
            case 3: invert = ((x + y) % 3) === 0; break;
            case 4: invert = (((x / 3) | 0) + ((y / 2) | 0)) % 2 === 0; break;
            case 5: invert = ((x * y) % 2 + (x * y) % 3) === 0; break;
            case 6: invert = (((x * y) % 2 + (x * y) % 3) % 2) === 0; break;
            case 7: invert = ((((x + y) % 2) + (x * y) % 3) % 2) === 0; break;
            default: throw new Error("Unreachable");
          }
          if (invert) row[x] = row[x] ^ 1;
        }
      }
    }

    getPenaltyScore() {
      let result = 0;
      const s = this.size;
      const modules = this.modules;

      for (let y = 0; y < s; ++y) {
        const row = modules[y];
        let runColor = 0;
        let runLen = 0;
        const runHistory = [0,0,0,0,0,0,0];
        for (let x = 0; x < s; ++x) {
          const color = row[x];
          if (color === runColor) {
            ++runLen;
            if (runLen === 5) result += QrCode.PENALTY_N1;
            else if (runLen > 5) ++result;
          } else {
            this.finderPenaltyAddHistory(runLen, runHistory);
            if (runColor === 0) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = color;
            runLen = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runLen, runHistory) * QrCode.PENALTY_N3;
      }

      for (let x = 0; x < s; ++x) {
        let runColor = 0;
        let runLen = 0;
        const runHistory = [0,0,0,0,0,0,0];
        for (let y = 0; y < s; ++y) {
          const color = modules[y][x];
          if (color === runColor) {
            ++runLen;
            if (runLen === 5) result += QrCode.PENALTY_N1;
            else if (runLen > 5) ++result;
          } else {
            this.finderPenaltyAddHistory(runLen, runHistory);
            if (runColor === 0) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = color;
            runLen = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runLen, runHistory) * QrCode.PENALTY_N3;
      }

      for (let y = 0; y < s - 1; ++y) {
        for (let x = 0; x < s - 1; ++x) {
          const c = modules[y][x];
          if (c === modules[y][x+1] && c === modules[y+1][x] && c === modules[y+1][x+1]) result += QrCode.PENALTY_N2;
        }
      }

      let dark = 0;
      for (let y = 0; y < s; ++y) {
        const row = modules[y];
        for (let x = 0; x < s; ++x) dark += row[x];
      }
      const total = s * s;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }

    getAlignmentPatternPositions() {
      if (this.version === 1) return [];
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = (this.version === 32) ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
      return result;
    }

    static getNumRawDataModules(ver) {
      if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7) result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }

    static getNumDataCodewords(ver, ecl) {
      return Math.floor(QrCode.getNumRawDataModules(ver) / 8) - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }

    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
      if (RS_DIV_CACHE.has(degree)) return RS_DIV_CACHE.get(degree).slice();

      const result = new Array(degree).fill(0);
      result[degree - 1] = 1;
      let root = 1;
      for (let i = 0; i < degree; ++i) {
        for (let j = 0; j < result.length; ++j) {
          result[j] = QrCode.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length) result[j] ^= result[j + 1];
        }
        root = QrCode.reedSolomonMultiply(root, 0x02);
      }
      RS_DIV_CACHE.set(degree, result.slice());
      return result;
    }

    static reedSolomonComputeRemainder(data, divisor) {
      const result = divisor.map(() => 0);
      for (const b of data) {
        const factor = b ^ result.shift();
        result.push(0);
        for (let i = 0; i < divisor.length; ++i) result[i] ^= QrCode.reedSolomonMultiply(divisor[i], factor);
      }
      return result;
    }

    static reedSolomonMultiply(x, y) {
      if ((x >>> 8) !== 0 || (y >>> 8) !== 0) throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; --i) {
        z = (z << 1) ^ ((z >>> 7) * 0x11D);
        z ^= ((y >>> i) & 1) * x;
      }
      assert((z >>> 8) === 0);
      return z;
    }

    finderPenaltyCountPatterns(runHistory) {
      const n = runHistory[1];
      assert(n <= this.size * 3);
      const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
    }

    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }

    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] === 0) currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  }

  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;

  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  ];

  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],
  ];

  qrcodegen.QrCode = QrCode;

  // QrSegment, Mode, Ecc definitions (kept functionally identical to original)
  (function (qrcodegen) {
    class QrSegment {
      constructor(mode, numChars, bitData) {
        this.mode = mode;
        this.numChars = numChars;
        this.bitData = bitData.slice();
        if (numChars < 0) throw new RangeError("Invalid argument");
      }

      static makeBytes(data) {
        const bb = [];
        for (const b of data) appendBits(b, 8, bb);
        return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
      }

      static makeNumeric(digits) {
        if (!QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
        const bb = [];
        for (let i = 0; i < digits.length;) {
          const n = Math.min(digits.length - i, 3);
          appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
          i += n;
        }
        return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
      }

      static makeAlphanumeric(text) {
        if (!QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
        const bb = [];
        let i;
        for (i = 0; i + 2 <= text.length; i += 2) {
          let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
          temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
          appendBits(temp, 11, bb);
        }
        if (i < text.length) appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
        return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
      }

      static makeSegments(text) {
        if (text === "") return [];
        else if (QrSegment.isNumeric(text)) return [QrSegment.makeNumeric(text)];
        else if (QrSegment.isAlphanumeric(text)) return [QrSegment.makeAlphanumeric(text)];
        else return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
      }

      static makeEci(assignVal) {
        const bb = [];
        if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
        else if (assignVal < (1 << 7)) appendBits(assignVal, 8, bb);
        else if (assignVal < (1 << 14)) { appendBits(0b10, 2, bb); appendBits(assignVal, 14, bb); }
        else if (assignVal < 1000000) { appendBits(0b110, 3, bb); appendBits(assignVal, 21, bb); }
        else throw new RangeError("ECI assignment value out of range");
        return new QrSegment(QrSegment.Mode.ECI, 0, bb);
      }

      static isNumeric(text) { return QrSegment.NUMERIC_REGEX.test(text); }
      static isAlphanumeric(text) { return QrSegment.ALPHANUMERIC_REGEX.test(text); }

      getData() { return this.bitData.slice(); }

      static getTotalBits(segs, version) {
        let result = 0;
        for (const seg of segs) {
          const ccbits = seg.mode.numCharCountBits(version);
          if (seg.numChars >= (1 << ccbits)) return Infinity;
          result += 4 + ccbits + seg.bitData.length;
        }
        return result;
      }

      static toUtf8ByteArray(str) {
        str = encodeURI(str);
        const result = [];
        for (let i = 0; i < str.length; ++i) {
          if (str.charAt(i) !== "%") result.push(str.charCodeAt(i));
          else { result.push(parseInt(str.substring(i + 1, i + 3), 16)); i += 2; }
        }
        return result;
      }
    }

    QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
    QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
    QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    qrcodegen.QrSegment = QrSegment;

    class Mode {
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      numCharCountBits(ver) { return this.numBitsCharCount[Math.floor((ver + 7) / 17)]; }
    }

    Mode.NUMERIC = new Mode(0x1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new Mode(0x2, [9, 11, 13]);
    Mode.BYTE = new Mode(0x4, [8, 16, 16]);
    Mode.KANJI = new Mode(0x8, [8, 10, 12]);
    Mode.ECI = new Mode(0x7, [0, 0, 0]);
    qrcodegen.QrSegment.Mode = Mode;

    class Ecc {
      constructor(ordinal, formatBits) { this.ordinal = ordinal; this.formatBits = formatBits; }
    }
    Ecc.LOW = new Ecc(0, 1);
    Ecc.MEDIUM = new Ecc(1, 0);
    Ecc.QUARTILE = new Ecc(2, 3);
    Ecc.HIGH = new Ecc(3, 2);
    qrcodegen.QrCode.Ecc = Ecc;
  })(qrcodegen);

})(qrcodegen);

  // --- Form <> data wiring -----------------------------------------
  function loadToForm(key, cfg) {
    $("codeKey").value = key;
    $("actionType").value = cfg.type;
    $("targetUrl").value = cfg.targetUrl || "";
    $("extraParams").value = cfg.extraParams ? JSON.stringify(cfg.extraParams, null, 2) : "";
    $("downloadUrl").value = cfg.downloadUrl || "";
    $("downloadName").value = cfg.downloadName || "";
    $("displayData").value = cfg.displayData || "";
    onActionTypeChange();
    renderQrForKey(key);
    setMessage("Loaded code '" + key + "' into form.");
  }

  function onActionTypeChange() {
    const type = $("actionType").value;
    show("field_targetUrl", type === "redirect" || type === "redirectWithParams");
    show("field_params", type === "redirectWithParams");
    show("field_download", type === "download");
    show("field_display", type === "display");
  }

  function currentBaseUrl() {
    return window.location.origin + window.location.pathname.replace(/[#?].*$/, "");
  }

  function renderQrForKey(key) {
    if (!key) {
      $("qrContainer").innerHTML = "";
      $("qrUrl").textContent = "";
      show("downloadSvgBtn", false);
      return;
    }
    const url = currentBaseUrl() + "?code=" + encodeURIComponent(key);
    $("qrUrl").textContent = url;

    let svg = "";
    try {
      svg = qrcodegen.displayQr(url).images.svg;//makeQrSvg(url, 4);
      $("qrContainer").innerHTML = svg;
      show("downloadSvgBtn", true);
      $("downloadSvgBtn").onclick = function () {
        const blob = new Blob([svg], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "qr-" + key + ".svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      };
    } catch (e) {
      $("qrContainer").textContent = "Could not render QR: " + e.message;
      show("downloadSvgBtn", false);
    }
  }

  function saveFromForm() {
    const key = $("codeKey").value.trim();
    if (!key) {
      setMessage("Key is required.");
      return;
    }
    const type = $("actionType").value;
    const codes = loadCodes();
    const cfg = { type: type };

    if (type === "redirect" || type === "redirectWithParams") {
      const url = $("targetUrl").value.trim();
      if (!url) {
        setMessage("Target URL is required for redirect.");
        return;
      }
      cfg.targetUrl = url;
      if (type === "redirectWithParams") {
        const raw = $("extraParams").value.trim();
        if (raw) {
          try {
            const obj = JSON.parse(raw);
            if (typeof obj !== "object" || Array.isArray(obj) || obj === null) {
              setMessage("Extra parameters must be a JSON object.");
              return;
            }
            cfg.extraParams = obj;
          } catch (e) {
            setMessage("Invalid JSON in extra parameters: " + e.message);
            return;
          }
        } else {
          cfg.extraParams = {};
        }
      }
    } else if (type === "download") {
      const dUrl = $("downloadUrl").value.trim();
      if (!dUrl) {
        setMessage("Download URL/data is required.");
        return;
      }
      cfg.downloadUrl = dUrl;
      cfg.downloadName = $("downloadName").value.trim() || "download";
    } else if (type === "display") {
      cfg.displayData = $("displayData").value;
    }

    codes[key] = cfg;
    saveCodes(codes);
    updateCodeList(codes);
    renderQrForKey(key);
    setMessage("Saved code '" + key + "'.");
  }

  // --- Action execution ---------------------------------------------
  function executeAction(key, cfg) {
    if (!cfg) {
      setMessage("No configuration found for code '" + key + "'.");
      show("adminUI", true);
      return;
    }
    const type = cfg.type;
    if (type === "redirect") {
      setMessage("Redirecting...");
      window.location.href = cfg.targetUrl;
    } else if (type === "redirectWithParams") {
      setMessage("Redirecting with parameters...");
      const url = new URL(cfg.targetUrl, window.location.href);
      const params = cfg.extraParams || {};
      Object.keys(params).forEach(k => {
        url.searchParams.set(k, params[k]);
      });
      // Also forward any existing query parameters (except 'code')
      const current = new URL(window.location.href);
      current.searchParams.forEach((v, k) => {
        if (k === "code") return;
        if (!url.searchParams.has(k)) {
          url.searchParams.set(k, v);
        }
      });
      window.location.href = url.toString();
    } else if (type === "download") {
      setMessage("Starting download...");
      const a = document.createElement("a");
      a.href = cfg.downloadUrl;
      a.download = cfg.downloadName || "download";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } else if (type === "display") {
      setMessage("Displaying content for code '" + key + "'.");
      show("displayArea", true);
      $("displayContent").innerHTML = cfg.displayData || "(no content)";
    } else {
      setMessage("Unknown action type for code '" + key + "'.");
    }
  }

  // --- Main entry logic ---------------------------------------------
  const params = new URLSearchParams(window.location.search);
  const codeKey = params.get("code");
  const codes = loadCodes();

  if (codeKey) {
    // handle QR action
    show("adminUI", false);
    executeAction(codeKey, codes[codeKey]);
  } else {
    // show admin interface
    show("adminUI", true);
    updateCodeList(codes);
    setMessage("Admin mode: create and manage dynamic QR codes.");
    onActionTypeChange();
    // bind events
    $("actionType").addEventListener("change", onActionTypeChange);
    $("saveCode").addEventListener("click", saveFromForm);
    $("codeKey").addEventListener("input", function () {
      renderQrForKey(this.value.trim());
    });
  }
})(); // end dynamicQRRouter IIFE
</script>
</body>
</html>

